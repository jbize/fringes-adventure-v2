---
description: This rule governs JavaScript development practices across the entire project. It should be applied whenever: (1) Writing or modifying JavaScript code, (2) Creating new JavaScript modules or functions, (3) Implementing client-side functionality, (4) Handling AJAX and DOM interactions, (5) Debugging JavaScript issues. The rule ensures consistent code style, proper error handling, and maintainable JavaScript architecture.
globs: 
alwaysApply: false
---

# JavaScript Best Practices

## Critical Rules

- Code Organization and Structure
  - Use ES6+ features appropriately (const/let, arrow functions, destructuring)
  - Organize code into modules with clear single responsibilities
  - Keep functions small and focused (max 20 lines recommended)
  - Use meaningful variable and function names that describe purpose
  - Maintain consistent indentation (2 spaces) and formatting

- Documentation and Comments
  - Document all functions with JSDoc comments including parameters and return types
  - Add inline comments for complex logic or business rules
  - Keep comments current when modifying code
  - Include example usage in comments for complex functions
  - Document any browser compatibility considerations

- Error Handling and Debugging
  - Use try-catch blocks for error-prone operations
  - Implement proper error logging and user feedback
  - Add descriptive error messages
  - Handle all promise rejections and async errors
  - Validate function inputs and handle edge cases

- Performance and Best Practices
  - Cache DOM queries and expensive operations
  - Use event delegation for dynamic elements
  - Debounce or throttle frequent events (scroll, resize)
  - Avoid global variables and namespace pollution
  - Clean up event listeners and intervals when no longer needed

- Testing and Maintenance
  - Write testable code with pure functions where possible
  - Add console.logs for debugging that are commented out in production
  - Use source maps in development
  - Follow consistent naming conventions
  - Keep dependencies updated and documented

## Examples

<example>
  // Good - Well documented function with error handling
  /**
   * Updates the inventory item count and refreshes the display
   * @param {string} itemId - The unique identifier of the item
   * @param {number} newCount - The new quantity of the item
   * @returns {Promise<void>} - Resolves when update is complete
   * @throws {Error} - If the update fails or validation fails
   */
  async function updateItemCount(itemId, newCount) {
    try {
      // Validate inputs
      if (!itemId || typeof newCount !== 'number') {
        throw new Error('Invalid input parameters');
      }

      // Cache DOM elements
      const itemElement = document.querySelector(`#item-${itemId}`);
      if (!itemElement) {
        throw new Error(`Item element not found: ${itemId}`);
      }

      // Make API call
      const response = await fetch('/api/inventory/update', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ itemId, count: newCount })
      });

      if (!response.ok) {
        throw new Error('Failed to update item');
      }

      // Update UI
      const countDisplay = itemElement.querySelector('.count');
      countDisplay.textContent = newCount;
      
      // Clean up any observers if needed
      if (this.observer) {
        this.observer.disconnect();
      }
    } catch (error) {
      console.error('Error updating item:', error);
      showUserError('Failed to update item. Please try again.');
      throw error;
    }
  }

  // Good - Event handling with delegation
  const inventoryList = document.querySelector('.inventory-list');
  inventoryList.addEventListener('click', (event) => {
    const itemButton = event.target.closest('.item-button');
    if (itemButton) {
      const itemId = itemButton.dataset.itemId;
      handleItemClick(itemId);
    }
  });

  // Good - Debounced search function
  const debounce = (fn, delay) => {
    let timeoutId;
    return (...args) => {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => fn(...args), delay);
    };
  };

  const searchItems = debounce((query) => {
    // Perform search operation
    performSearch(query);
  }, 300);
</example>

<example type="invalid">
  // Bad - Poor error handling and global variables
  var items = []; // Global variable
  
  function updateItem(id, count) {
    // No input validation
    $.post('/api/update', { id, count })
      .then(() => {
        // Direct DOM manipulation without checks
        document.getElementById(id).innerHTML = count;
      });
  }

  // Bad - Event listener without cleanup
  window.addEventListener('scroll', function() {
    // Unthrottled scroll handler
    updateScroll();
  });

  // Bad - No documentation or error handling
  function process(data) {
    let x = data.something;
    if (x) {
      doStuff();
    }
  }

  // Bad - Complex function without comments
  function handleThing(x, y, z) {
    let a = x.map(i => i * 2);
    let b = y.filter(i => i > 0);
    return a.concat(b).reduce((acc, val) => acc + val, 0);
  }
</example> 