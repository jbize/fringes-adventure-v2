---
description: This rule governs FastAPI development practices for the Fringes Adventure v2 project. It should be applied whenever: (1) Creating new FastAPI endpoints and routes, (2) Designing API schemas and models, (3) Implementing authentication and security, (4) Setting up database connections and ORM, (5) Creating middleware and dependencies, (6) Writing API documentation and OpenAPI specs, (7) Implementing error handling and validation, (8) Setting up testing for FastAPI applications. The rule ensures modern async patterns, proper API design, security best practices, and maintainable FastAPI code structure.
globs: 
alwaysApply: false
---

# FastAPI Best Practices for Fringes Adventure v2

## Critical Rules

- Use async/await patterns consistently throughout the application
  - All route handlers should be async functions
  - Use async database operations with SQLAlchemy 2.0
  - Implement proper async error handling
  - Use background tasks for long-running operations

- Implement proper Pydantic models for all data structures
  - Create request/response models for all endpoints
  - Use Field validators for complex validation logic
  - Implement proper type hints throughout
  - Use Config classes for model configuration

- Follow RESTful API design principles
  - Use proper HTTP methods (GET, POST, PUT, DELETE)
  - Return appropriate HTTP status codes
  - Implement proper error responses with consistent format
  - Use resource-based URL patterns

- Implement comprehensive security measures
  - Use JWT tokens for authentication
  - Implement proper CORS configuration
  - Use dependency injection for security checks
  - Validate all input data with Pydantic
  - Implement rate limiting for API endpoints

- Structure the application with proper separation of concerns
  - Separate routes, models, services, and utilities
  - Use dependency injection for database sessions
  - Implement proper error handling middleware
  - Create reusable dependencies for common operations

- Implement comprehensive testing
  - Use pytest-asyncio for async testing
  - Test all endpoints with proper fixtures
  - Mock external dependencies
  - Test error conditions and edge cases

## Examples

<example>
  # Good FastAPI Implementation
  ```python
  from fastapi import FastAPI, Depends, HTTPException, status
  from fastapi.security import HTTPBearer
  from pydantic import BaseModel, Field
  from sqlalchemy.ext.asyncio import AsyncSession
  from typing import List, Optional
  
  app = FastAPI(title="Fringes Adventure v2", version="2.0.0")
  
  # Pydantic models
  class UserCreate(BaseModel):
      username: str = Field(..., min_length=3, max_length=50)
      password: str = Field(..., min_length=8)
  
  class UserResponse(BaseModel):
      id: int
      username: str
      is_admin: bool
      
      class Config:
          from_attributes = True
  
  # Dependencies
  async def get_db() -> AsyncSession:
      async with async_session() as session:
          yield session
  
  async def get_current_user(
      token: str = Depends(HTTPBearer()),
      db: AsyncSession = Depends(get_db)
  ) -> User:
      # JWT validation logic
      pass
  
  # Routes
  @app.post("/users", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
  async def create_user(
      user_data: UserCreate,
      db: AsyncSession = Depends(get_db)
  ):
      # User creation logic
      pass
  
  @app.get("/users/me", response_model=UserResponse)
  async def get_current_user_info(
      current_user: User = Depends(get_current_user)
  ):
      return current_user
  ```
</example>

<example type="invalid">
  # Bad FastAPI Implementation
  ```python
  from flask import Flask, request, jsonify
  import sqlite3
  
  app = Flask(__name__)
  
  @app.route("/users", methods=["POST"])
  def create_user():
      # Synchronous code, no validation, no proper error handling
      data = request.get_json()
      conn = sqlite3.connect("database.db")
      cursor = conn.cursor()
      cursor.execute("INSERT INTO users VALUES (?, ?)", (data["username"], data["password"]))
      conn.commit()
      return jsonify({"message": "User created"})
  ```
</example>
